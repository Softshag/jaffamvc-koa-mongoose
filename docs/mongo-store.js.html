<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: mongo-store.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: mongo-store.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

let assign = require('object-assign'),
  mongoose = require('mongoose'),
  util = require('util'),
  co = require('co'),
  Promise = require('native-or-bluebird'),
  EventEmitter = require('events').EventEmitter,
  errors = require('./errors'),
  Parser = require('./parser'),
  Path = require('path'),
  jaffamvc = require('jaffamvc-koa'),
  debug = require('debug')('mvc:mongoose'),
  fs = require('mz/fs');

module.exports = MongoStore;

/**
 * MongoStore
 * @constructor MongoStore
 * @param {Object} options options
 * @param {String} options.host mongo host
 * @param {Number} options.port mongo port
 * @param {String} options.db mongo database
 * @param {String} [options.user] mongo user
 * @param {String} [options.password]  password
 * @extends {EventEmitter}
 */
function MongoStore(options) {
  this.opts = options;
  this.connection = null;

  this._schemas = {};
  this._models = {};
  this.parser = new Parser(options);
}

util.inherits(MongoStore, EventEmitter);

Object.defineProperty(MongoStore.prototype, 'db', {
  get: function() {
    if (this.connection == null) return null;
    return this.connection.db;
  }
});

assign(MongoStore.prototype, {
  /**
   * Connect to mongodb
   * @memberOf MongoStore#
   * @return {Promise}
   */
  connect: function() {
    return co(function * () {

      this.connection = yield getConnection(this.opts);

      this.delegateEvents();


      if (this.opts.models) {
        debug('using model patH: %s', this.opts.models);
        let dp = Path.resolve(this.opts.models, 'schemas');

        if (yield fs.exists(dp)) {
          debug('using schema path: %s', dp);
          this.parser.path = dp;

          yield this.parser.initialize();
        }



        let schemas = yield initSchemas(this.opts.models, this.parser);
        this._schemas = schemas;
      }


    }.bind(this));
  },

  /**
   * Disconnect
   * @memberOf MongoStore#
   * @return {Promise}
   */
  disconnect: function(force) {
    force = force || true;

    if (this.connection) {
      var self = this;
      this.undelegateEvents();
      return new Promise(function(resolve, reject) {
        self.connection.close(function(err) {
          if (err) return reject(err);
          self.connection = null;
          resolve();
        });
      });
    }
    return Promise.resolve();
  },

  /**
   * Drop the database
   * @memberOf MongoStore
   * @return {Promise}
   */
  dropDataBase: function() {
    let self = this;
    return new Promise(function(resolve, reject) {
      if (self.db == null) {
        return reject(errors.create(400, 'Not connected'));
      }
      return self.db.dropDatabase(function(err) {
        if (err != null) {
          return reject(err);
        }
        return resolve();
      });
    });

  },

  /**
   * Drop a collection
   * @param  {String} col the name of the collection
   * @memberOf MongoStore#
   * @return {Promise}
   */
  dropCollection: function(col) {
    return this.model(col).remove().exec();
  },

  /**
   * Get the names of all collections in the database
   * @memberOf MongoStore#
   * @return {Promise&lt;Array&lt;String>>}
   */
  collectionNames: function() {
    var self = this;
    return new Promise(function(resolve, reject) {
      let cols, dbName;
      if (self.db == null) {
        return reject(errors.create(400, 'Not connected'));
      }
      dbName = self.db.databaseName;
      cols = Object.keys(self.connection.collections);
      return resolve(cols);
    });

  },

  /**
   * Check whether a collection exists
   * @memberOf MongoStore#
   * @param  {String}  col the name of the collection
   * @return {Promise&lt;Boolean>}
   */
  hasCollection: function(col) {
    return this.collectionNames().then(function(cols) {
      if (~cols.indexOf(col)) return true;
      return false;
    });
  },

  /**
   * Get model
   * @param  {String} name  - the name of the model
   * @return {Mongoose.Model}
   * @memberOf MongoStore#
   */
  model: function(name) {
    let model, schema = this.schema(name);
    if (!schema) return null;

    try {
      model = mongoose.model(name);
    } catch (e) {
      model = mongoose.model(name, schema);
    }
    return model;
  },

  /**
   * Get schema
   * @param  {String} name the name of the schema
   * @return {mongoose.Schema}
   * @memberOf MongoStore#
   */
  schema: function(name) {
    if (this._schemas.hasOwnProperty(name)) {
      return this._schemas[name];
    }

    let def = this.parser.get(name);

    if (!def) return null;

    let schema = new mongoose.Schema(def);

    this._schemas[name] = schema;

    return schema;
  },

  /**
   * @private
   */
  delegateEvents: function() {
    this.connection.on('error', function(err) {
      this.trigger('error', err);
    }.bind(this));
  },

  /**
   * @private
   */
  undelegateEvents: function() {
    this.connection.removeAllListeners('error');
  }

});


/* Privates */
function getConnectionString(opts) {
  let str = '';
  if (opts.user &amp;&amp; opts.pass)
    str = opts.user + ':' + opts.pass;
  return util.format('mongodb://%s%s:%s/%s', str, opts.host, opts.port, opts.db);
}

function getConnection(opts) {
  var cStr = getConnectionString(opts);

  return new Promise(function(resolve, reject) {
    debug('connecting to %s', cStr);

    mongoose.connect(cStr);

    let conn = mongoose.connection;

    conn.once('open', function() {
      debug('connection open');
      conn.removeListener('error', reject);
      resolve(conn);
    });

    conn.once('error', function(err) {
      conn.removeListener('open', resolve);
      reject(err);
    });

  });
}

function initSchemas(modelPath, parser) {
  let schemas = {},
    self = this,
    schema;
  modelPath = Path.resolve(modelPath);

  return jaffamvc.utils.requireDir(modelPath, function * (mod, file) {

    let basename = Path.basename(file, Path.extname(file));

    debug('loading schema: %s', basename);
    schemas[basename] = schema = mod.call(self, mongoose.Schema, parser);
    debug('initializing model: %s', basename);

    if (schema) {
      schema.set('autoIndex', process.env.NODE_ENV === 'development');
    }
  }).then(function() {
    return schemas;
  });
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="MongoStore.html">MongoStore</a></li></ul><h3>Global</h3><ul><li><a href="global.html#delegateEvents">delegateEvents</a></li><li><a href="global.html#undelegateEvents">undelegateEvents</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-beta2</a> on Wed Mar 18 2015 00:31:32 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
